{
    "docs": [
        {
            "location": "/",
            "text": "Retrace\n\u00b6\n\n\nDealing with some unstable code? Be it a bad connection or system that often\nfall over retrace is here to help. Simple, easy and configurable method\nretrying with a nice clean API.\n\n\nDon't manually fudge around with exception retrying again!\n\n\nInstallation\n\u00b6\n\n\nInstall from pip\n\u00b6\n\n\nInstallation from pip is simple, just use\n\n\npip install retrace\n\n\n\n\n\nVendoring\n\u00b6\n\n\nIf you don't want to add a new dependency for such a small tool, you are in\nluck! Retrace is designed to be easily vendor-able! Simply head to the\n\nGitHub repo\n, grab the \nretrace.py\n file\nand include it in your project tree. Then, for example, say you add it under\n\nmyproject.utils.retrace\n then you just need to use that import path in the\nexamples below.\n\n\nUsage Examples\n\u00b6\n\n\nRetrying, on all exceptions\n\u00b6\n\n\nIf you want to retry a function call on any exception you can use the decorator\nwith no arguments.\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\n\n\nNote\n\n\nBy default this will catch all subclasses of Exception, meaning it wont\ncatch a anything that subclasses BaseException directly like\nKeyboardInterupt. \nAlso, by default, it will retry 5 times.\n\n\n\n\nRetrying specific exceptions only\n\u00b6\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\non_exeption\n=\nIOError\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nDelaying between retries\n\u00b6\n\n\nIf you want to delay between retries you can pass in an int or interval object.\nInterval objects are given information and then return the sleep in seconds. If\nan int is passed that will be used instead.\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\ninterval\n=\n5\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nLimit the number of attempts\n\u00b6\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\nlimit\n=\n5\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nCustom Retry Handling\n\u00b6\n\n\nCustomising the behaviour is a breeze, if you have some specific logic you\nwant to implement.\n\n\nFor example, here is a exponential backoff. It will increase the delay between\neach attempt. To do this, a method needs to be passed that accepts one\nargument. The argument is the the current attempt integer.\n\n\nimport\n \ntime\n\n\nimport\n \nretrace\n\n\n\ndef\n \nexponential_backoff\n(\nattempt_number\n):\n\n    \ntime\n.\nsleep\n(\nattempt_number\n \n*\n \n2\n)\n\n\n\n@retrace.retry\n(\nsleep\n=\nexponential_backoff\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nSimilarly, the same behaviour can be used to control the retrying behaviour.\nIn this artificial example, the retry limit is 10 in the afternoon, but only 5\nin them orning.\n\n\nimport\n \ndatetime\n\n\nimport\n \nretrace\n\n\n\ndef\n \ntry_more_in_the_afternoon\n(\nattempt_number\n):\n\n\n    \nnow\n \n=\n \ndatetime\n.\ndatetime\n.\nnow\n()\n\n    \nif\n \nnow\n.\nhour\n \n<\n \n12\n \nand\n \nattempt_number\n \n>\n \n5\n:\n\n        \nraise\n \nretrace\n.\nLimitException\n()\n\n    \nelif\n \nattempt_number\n \n>\n \n10\n:\n\n        \nraise\n \nretrace\n.\nLimitException\n()\n\n\n\n@retrace.retry\n(\nlimit\n=\ntry_more_in_the_afternoon\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...",
            "title": "Home"
        },
        {
            "location": "/#retrace",
            "text": "Dealing with some unstable code? Be it a bad connection or system that often\nfall over retrace is here to help. Simple, easy and configurable method\nretrying with a nice clean API.  Don't manually fudge around with exception retrying again!",
            "title": "Retrace"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#install-from-pip",
            "text": "Installation from pip is simple, just use  pip install retrace",
            "title": "Install from pip"
        },
        {
            "location": "/#vendoring",
            "text": "If you don't want to add a new dependency for such a small tool, you are in\nluck! Retrace is designed to be easily vendor-able! Simply head to the GitHub repo , grab the  retrace.py  file\nand include it in your project tree. Then, for example, say you add it under myproject.utils.retrace  then you just need to use that import path in the\nexamples below.",
            "title": "Vendoring"
        },
        {
            "location": "/#usage-examples",
            "text": "",
            "title": "Usage Examples"
        },
        {
            "location": "/#retrying-on-all-exceptions",
            "text": "If you want to retry a function call on any exception you can use the decorator\nwith no arguments.  import   retrace  @retrace.retry  def   unstable (): \n     # ...    Note  By default this will catch all subclasses of Exception, meaning it wont\ncatch a anything that subclasses BaseException directly like\nKeyboardInterupt.  Also, by default, it will retry 5 times.",
            "title": "Retrying, on all exceptions"
        },
        {
            "location": "/#retrying-specific-exceptions-only",
            "text": "import   retrace  @retrace.retry ( on_exeption = IOError )  def   unstable (): \n     # ...",
            "title": "Retrying specific exceptions only"
        },
        {
            "location": "/#delaying-between-retries",
            "text": "If you want to delay between retries you can pass in an int or interval object.\nInterval objects are given information and then return the sleep in seconds. If\nan int is passed that will be used instead.  import   retrace  @retrace.retry ( interval = 5 )  def   unstable (): \n     # ...",
            "title": "Delaying between retries"
        },
        {
            "location": "/#limit-the-number-of-attempts",
            "text": "import   retrace  @retrace.retry ( limit = 5 )  def   unstable (): \n     # ...",
            "title": "Limit the number of attempts"
        },
        {
            "location": "/#custom-retry-handling",
            "text": "Customising the behaviour is a breeze, if you have some specific logic you\nwant to implement.  For example, here is a exponential backoff. It will increase the delay between\neach attempt. To do this, a method needs to be passed that accepts one\nargument. The argument is the the current attempt integer.  import   time  import   retrace  def   exponential_backoff ( attempt_number ): \n     time . sleep ( attempt_number   *   2 )  @retrace.retry ( sleep = exponential_backoff )  def   unstable (): \n     # ...   Similarly, the same behaviour can be used to control the retrying behaviour.\nIn this artificial example, the retry limit is 10 in the afternoon, but only 5\nin them orning.  import   datetime  import   retrace  def   try_more_in_the_afternoon ( attempt_number ): \n\n     now   =   datetime . datetime . now () \n     if   now . hour   <   12   and   attempt_number   >   5 : \n         raise   retrace . LimitException () \n     elif   attempt_number   >   10 : \n         raise   retrace . LimitException ()  @retrace.retry ( limit = try_more_in_the_afternoon )  def   unstable (): \n     # ...",
            "title": "Custom Retry Handling"
        }
    ]
}