{
    "docs": [
        {
            "location": "/",
            "text": "Retrace - Configurable retrying for Pythonistas.\n\u00b6\n\n\n\n\n\n\n\n\n\n\n\n\nDealing with some unstable code? Be it a bad connection or system that often\nfall over retrace is here to help. Simple, easy and configurable method\nretrying with a nice clean API.\n\n\nDon't manually fudge around with exception retrying again!\n\n\nRetrace supports Python 2.7 and 3.3+.\n\n\nInstallation\n\u00b6\n\n\nInstall from pip\n\u00b6\n\n\nInstallation from pip is simple, like so:\n\n\npip install retrace\n\n\n\n\n\nVendoring\n\u00b6\n\n\nIf you don't want to add a new dependency for such a small tool, you are in\nluck! Retrace is \ndesigned to be easily vendor-able!\n Simply head to the\n\nGitHub repo\n, grab the \nretrace.py\n file\nand include it in your project tree. Then, for example, say you add it under\n\nmyproject.utils.retrace\n then you just need to use that import path in the\nexamples below.\n\n\n\n\nNote\n\n\nIf you choose to vendor retrace, you will need to manually version it\nyourself. We recommend that you pick the latest git tag to get the most\nrecent stable version.\n\n\n\n\nUsage Examples\n\u00b6\n\n\nRetry all exceptions\n\u00b6\n\n\nIf you want to retry a function call on any exception you can use the decorator\nwith no arguments. \nBy default this will retry 5 times.\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\n\n\nNote\n\n\nBy default this will catch all subclasses of Exception, meaning it wont\ncatch a anything that subclasses BaseException directly like\nKeyboardInterupt.\n\n\n\n\nRetry on a specific exception type\n\u00b6\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\non_exeption\n=\nIOError\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nDelaying between retries\n\u00b6\n\n\nIf you want to delay between retries you can pass in a number which is equal\nto the number of seconds to delay between retrying. For example, wait a second\nbetween attempts\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\ninterval\n=\n1\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nLimit the number of attempts\n\u00b6\n\n\nBy default retrace will retry 5 times, if you want to change that, pass in a\nnew limit.\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\nlimit\n=\n10\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nGradually delay more between attempts\n\u00b6\n\n\nHere is a neat trick - if you want to delay between each try, and have that\nincrease with each attempt you can pass \ntime.sleep\n in as your interval\nfunction! This will mean after the first attempt it will sleep for one second,\nthen two seconds, three seconds etc.\n\n\nThis works because you can use \nfunctions as the delay\n, they must accept one argument which is the current retry number. So\nwith \ntime.sleep\n, the code sleeps for a the number of seconds equal to the\nattempt number.\n\n\nimport\n \ntime\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\ninterval\n=\ntime\n.\nsleep\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nCustom Retry Handling\n\u00b6\n\n\nlimits and intervals\n\u00b6\n\n\nOkay, we touched on this, but let's just state it here clearly. The retry\ndecorator takes two different arguments for controlling it's behaviour, limit\nand interval. These are similar, but different. Limit controls how many times\nwe should retry before giving up. Interval controls how much delay happens\nbetween retry attempts.\n\n\nControlling the interval between retries\n\u00b6\n\n\nCustomising the interval, the delay between retries, is a breeze, if you have\nsome specific logic you want to implement.\n\n\nFor example, here is a exponential backoff. It will increase the delay between\neach attempt. To do this, a method needs to be passed that accepts one\nargument. The argument is the the current attempt integer.\n\n\nimport\n \ntime\n\n\nimport\n \nretrace\n\n\n\ndef\n \nexponential_backoff\n(\nattempt_number\n):\n\n    \ntime\n.\nsleep\n(\nattempt_number\n \n+\n \n(\nrandom\n.\nrandom\n()\n \n*\n \nattempt_number\n)\n\n\n\n@retrace.retry\n(\ninterval\n=\nexponential_backoff\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nLimiting the number of reties\n\u00b6\n\n\nSimilarly, the same approach can be used to limit the number of retries. In\nthis artificial example, the retry limit is 10 in the afternoon, but only 5\nin them morning.\n\n\nimport\n \ndatetime\n\n\nimport\n \nretrace\n\n\n\ndef\n \ntry_more_in_the_afternoon\n(\nattempt_number\n):\n\n\n    \nnow\n \n=\n \ndatetime\n.\ndatetime\n.\nnow\n()\n\n    \nif\n \nnow\n.\nhour\n \n<\n \n12\n \nand\n \nattempt_number\n \n>\n \n5\n:\n\n        \nraise\n \nretrace\n.\nLimitReached\n()\n\n    \nelif\n \nattempt_number\n \n>\n \n10\n:\n\n        \nraise\n \nretrace\n.\nLimitReached\n()\n\n\n\n@retrace.retry\n(\nlimit\n=\ntry_more_in_the_afternoon\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...",
            "title": "Home"
        },
        {
            "location": "/#retrace-configurable-retrying-for-pythonistas",
            "text": "Dealing with some unstable code? Be it a bad connection or system that often\nfall over retrace is here to help. Simple, easy and configurable method\nretrying with a nice clean API.  Don't manually fudge around with exception retrying again!  Retrace supports Python 2.7 and 3.3+.",
            "title": "Retrace - Configurable retrying for Pythonistas."
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#install-from-pip",
            "text": "Installation from pip is simple, like so:  pip install retrace",
            "title": "Install from pip"
        },
        {
            "location": "/#vendoring",
            "text": "If you don't want to add a new dependency for such a small tool, you are in\nluck! Retrace is  designed to be easily vendor-able!  Simply head to the GitHub repo , grab the  retrace.py  file\nand include it in your project tree. Then, for example, say you add it under myproject.utils.retrace  then you just need to use that import path in the\nexamples below.   Note  If you choose to vendor retrace, you will need to manually version it\nyourself. We recommend that you pick the latest git tag to get the most\nrecent stable version.",
            "title": "Vendoring"
        },
        {
            "location": "/#usage-examples",
            "text": "",
            "title": "Usage Examples"
        },
        {
            "location": "/#retry-all-exceptions",
            "text": "If you want to retry a function call on any exception you can use the decorator\nwith no arguments.  By default this will retry 5 times.  import   retrace  @retrace.retry  def   unstable (): \n     # ...    Note  By default this will catch all subclasses of Exception, meaning it wont\ncatch a anything that subclasses BaseException directly like\nKeyboardInterupt.",
            "title": "Retry all exceptions"
        },
        {
            "location": "/#retry-on-a-specific-exception-type",
            "text": "import   retrace  @retrace.retry ( on_exeption = IOError )  def   unstable (): \n     # ...",
            "title": "Retry on a specific exception type"
        },
        {
            "location": "/#delaying-between-retries",
            "text": "If you want to delay between retries you can pass in a number which is equal\nto the number of seconds to delay between retrying. For example, wait a second\nbetween attempts  import   retrace  @retrace.retry ( interval = 1 )  def   unstable (): \n     # ...",
            "title": "Delaying between retries"
        },
        {
            "location": "/#limit-the-number-of-attempts",
            "text": "By default retrace will retry 5 times, if you want to change that, pass in a\nnew limit.  import   retrace  @retrace.retry ( limit = 10 )  def   unstable (): \n     # ...",
            "title": "Limit the number of attempts"
        },
        {
            "location": "/#gradually-delay-more-between-attempts",
            "text": "Here is a neat trick - if you want to delay between each try, and have that\nincrease with each attempt you can pass  time.sleep  in as your interval\nfunction! This will mean after the first attempt it will sleep for one second,\nthen two seconds, three seconds etc.  This works because you can use  functions as the delay , they must accept one argument which is the current retry number. So\nwith  time.sleep , the code sleeps for a the number of seconds equal to the\nattempt number.  import   time  import   retrace  @retrace.retry ( interval = time . sleep )  def   unstable (): \n     # ...",
            "title": "Gradually delay more between attempts"
        },
        {
            "location": "/#custom-retry-handling",
            "text": "",
            "title": "Custom Retry Handling"
        },
        {
            "location": "/#limits-and-intervals",
            "text": "Okay, we touched on this, but let's just state it here clearly. The retry\ndecorator takes two different arguments for controlling it's behaviour, limit\nand interval. These are similar, but different. Limit controls how many times\nwe should retry before giving up. Interval controls how much delay happens\nbetween retry attempts.",
            "title": "limits and intervals"
        },
        {
            "location": "/#controlling-the-interval-between-retries",
            "text": "Customising the interval, the delay between retries, is a breeze, if you have\nsome specific logic you want to implement.  For example, here is a exponential backoff. It will increase the delay between\neach attempt. To do this, a method needs to be passed that accepts one\nargument. The argument is the the current attempt integer.  import   time  import   retrace  def   exponential_backoff ( attempt_number ): \n     time . sleep ( attempt_number   +   ( random . random ()   *   attempt_number )  @retrace.retry ( interval = exponential_backoff )  def   unstable (): \n     # ...",
            "title": "Controlling the interval between retries"
        },
        {
            "location": "/#limiting-the-number-of-reties",
            "text": "Similarly, the same approach can be used to limit the number of retries. In\nthis artificial example, the retry limit is 10 in the afternoon, but only 5\nin them morning.  import   datetime  import   retrace  def   try_more_in_the_afternoon ( attempt_number ): \n\n     now   =   datetime . datetime . now () \n     if   now . hour   <   12   and   attempt_number   >   5 : \n         raise   retrace . LimitReached () \n     elif   attempt_number   >   10 : \n         raise   retrace . LimitReached ()  @retrace.retry ( limit = try_more_in_the_afternoon )  def   unstable (): \n     # ...",
            "title": "Limiting the number of reties"
        }
    ]
}