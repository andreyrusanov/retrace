{
    "docs": [
        {
            "location": "/",
            "text": "Retrace - Configurable retrying for Pythonistas.\n\u00b6\n\n\nDealing with some unstable code? Be it a bad connection or system that often\nfall over retrace is here to help. Simple, easy and configurable method\nretrying with a nice clean API.\n\n\nDon't manually fudge around with exception retrying again!\n\n\nRetrace supports Python 2.7 and 3.3+.\n\n\nInstallation\n\u00b6\n\n\nInstall from pip\n\u00b6\n\n\nInstallation from pip is simple, like so:\n\n\npip install retrace\n\n\n\n\n\nVendoring\n\u00b6\n\n\nIf you don't want to add a new dependency for such a small tool, you are in\nluck! Retrace is \ndesigned to be easily vendor-able!\n Simply head to the\n\nGitHub repo\n, grab the \nretrace.py\n file\nand include it in your project tree. Then, for example, say you add it under\n\nmyproject.utils.retrace\n then you just need to use that import path in the\nexamples below.\n\n\n\n\nNote\n\n\nIf you choose to vendor retrace, you will need to manually version it\nyourself. We recommend that you pick the latest git tag to get the most\nrecent stable version.\n\n\n\n\nUsage Examples\n\u00b6\n\n\nRetry all exceptions\n\u00b6\n\n\nIf you want to retry a function call on any exception you can use the decorator\nwith no arguments. \nBy default this will retry 5 times.\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\n\n\nNote\n\n\nBy default this will catch all subclasses of Exception, meaning it wont\ncatch a anything that subclasses BaseException directly like\nKeyboardInterupt.\n\n\n\n\nRetry on a specific exception type\n\u00b6\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\non_exeption\n=\nIOError\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nDelaying between retries\n\u00b6\n\n\nIf you want to delay between retries you can pass in a number which is equal\nto the number of seconds to delay between retrying. For example, wait a second\nbetween attempts\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\ninterval\n=\n1\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nLimit the number of attempts\n\u00b6\n\n\nBy default retrace will retry 5 times, if you want to change that, pass in a\nnew limit.\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\nlimit\n=\n10\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nGradually delay more between attempts\n\u00b6\n\n\nimport\n \ntime\n\n\nimport\n \nretrace\n\n\n\n@retrace.retry\n(\ninterval\n=\ntime\n.\nsleep\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nCustom Retry Handling\n\u00b6\n\n\nCustomising the behaviour is a breeze, if you have some specific logic you\nwant to implement.\n\n\nFor example, here is a exponential backoff. It will increase the delay between\neach attempt. To do this, a method needs to be passed that accepts one\nargument. The argument is the the current attempt integer.\n\n\nimport\n \ntime\n\n\nimport\n \nretrace\n\n\n\ndef\n \nexponential_backoff\n(\nattempt_number\n):\n\n    \ntime\n.\nsleep\n(\nattempt_number\n \n*\n \n2\n)\n\n\n\n@retrace.retry\n(\ninterval\n=\nexponential_backoff\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...\n\n\n\n\n\n\nSimilarly, the same behaviour can be used to control the retrying behaviour.\nIn this artificial example, the retry limit is 10 in the afternoon, but only 5\nin them orning.\n\n\nimport\n \ndatetime\n\n\nimport\n \nretrace\n\n\n\ndef\n \ntry_more_in_the_afternoon\n(\nattempt_number\n):\n\n\n    \nnow\n \n=\n \ndatetime\n.\ndatetime\n.\nnow\n()\n\n    \nif\n \nnow\n.\nhour\n \n<\n \n12\n \nand\n \nattempt_number\n \n>\n \n5\n:\n\n        \nraise\n \nretrace\n.\nLimitReached\n()\n\n    \nelif\n \nattempt_number\n \n>\n \n10\n:\n\n        \nraise\n \nretrace\n.\nLimitReached\n()\n\n\n\n@retrace.retry\n(\nlimit\n=\ntry_more_in_the_afternoon\n)\n\n\ndef\n \nunstable\n():\n\n    \n# ...",
            "title": "Home"
        },
        {
            "location": "/#retrace-configurable-retrying-for-pythonistas",
            "text": "Dealing with some unstable code? Be it a bad connection or system that often\nfall over retrace is here to help. Simple, easy and configurable method\nretrying with a nice clean API.  Don't manually fudge around with exception retrying again!  Retrace supports Python 2.7 and 3.3+.",
            "title": "Retrace - Configurable retrying for Pythonistas."
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#install-from-pip",
            "text": "Installation from pip is simple, like so:  pip install retrace",
            "title": "Install from pip"
        },
        {
            "location": "/#vendoring",
            "text": "If you don't want to add a new dependency for such a small tool, you are in\nluck! Retrace is  designed to be easily vendor-able!  Simply head to the GitHub repo , grab the  retrace.py  file\nand include it in your project tree. Then, for example, say you add it under myproject.utils.retrace  then you just need to use that import path in the\nexamples below.   Note  If you choose to vendor retrace, you will need to manually version it\nyourself. We recommend that you pick the latest git tag to get the most\nrecent stable version.",
            "title": "Vendoring"
        },
        {
            "location": "/#usage-examples",
            "text": "",
            "title": "Usage Examples"
        },
        {
            "location": "/#retry-all-exceptions",
            "text": "If you want to retry a function call on any exception you can use the decorator\nwith no arguments.  By default this will retry 5 times.  import   retrace  @retrace.retry  def   unstable (): \n     # ...    Note  By default this will catch all subclasses of Exception, meaning it wont\ncatch a anything that subclasses BaseException directly like\nKeyboardInterupt.",
            "title": "Retry all exceptions"
        },
        {
            "location": "/#retry-on-a-specific-exception-type",
            "text": "import   retrace  @retrace.retry ( on_exeption = IOError )  def   unstable (): \n     # ...",
            "title": "Retry on a specific exception type"
        },
        {
            "location": "/#delaying-between-retries",
            "text": "If you want to delay between retries you can pass in a number which is equal\nto the number of seconds to delay between retrying. For example, wait a second\nbetween attempts  import   retrace  @retrace.retry ( interval = 1 )  def   unstable (): \n     # ...",
            "title": "Delaying between retries"
        },
        {
            "location": "/#limit-the-number-of-attempts",
            "text": "By default retrace will retry 5 times, if you want to change that, pass in a\nnew limit.  import   retrace  @retrace.retry ( limit = 10 )  def   unstable (): \n     # ...",
            "title": "Limit the number of attempts"
        },
        {
            "location": "/#gradually-delay-more-between-attempts",
            "text": "import   time  import   retrace  @retrace.retry ( interval = time . sleep )  def   unstable (): \n     # ...",
            "title": "Gradually delay more between attempts"
        },
        {
            "location": "/#custom-retry-handling",
            "text": "Customising the behaviour is a breeze, if you have some specific logic you\nwant to implement.  For example, here is a exponential backoff. It will increase the delay between\neach attempt. To do this, a method needs to be passed that accepts one\nargument. The argument is the the current attempt integer.  import   time  import   retrace  def   exponential_backoff ( attempt_number ): \n     time . sleep ( attempt_number   *   2 )  @retrace.retry ( interval = exponential_backoff )  def   unstable (): \n     # ...   Similarly, the same behaviour can be used to control the retrying behaviour.\nIn this artificial example, the retry limit is 10 in the afternoon, but only 5\nin them orning.  import   datetime  import   retrace  def   try_more_in_the_afternoon ( attempt_number ): \n\n     now   =   datetime . datetime . now () \n     if   now . hour   <   12   and   attempt_number   >   5 : \n         raise   retrace . LimitReached () \n     elif   attempt_number   >   10 : \n         raise   retrace . LimitReached ()  @retrace.retry ( limit = try_more_in_the_afternoon )  def   unstable (): \n     # ...",
            "title": "Custom Retry Handling"
        }
    ]
}